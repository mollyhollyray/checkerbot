const github = require('./github');
const storage = require('./storage');
const { log, logError } = require('../utils/logger');

module.exports = {
  async checkAllRepos(bot) {
    const startTime = Date.now();
    let processedRepos = 0;
    let successfulChecks = 0;
    let failedChecks = 0;

    try {
      const repos = storage.getRepos();
      if (!repos || repos.length === 0) {
        log('–ù–µ—Ç —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–µ–≤ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏', 'info', { 
          context: 'checkAllRepos',
          reposCount: 0 
        });
        return [];
      }

      log(`–ù–∞—á–∏–Ω–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É ${repos.length} —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–µ–≤`, 'info', {
        context: 'checkAllRepos',
        reposCount: repos.length,
        repoKeys: repos.map(([key]) => key)
      });

      const updates = [];

      for (const [repoKey, repoData] of repos) {
        processedRepos++;
        try {
          const [owner, repo] = repoKey.split('/');
          const branch = repoData.branch || repoData.defaultBranch || 'main';

          log(`–ü—Ä–æ–≤–µ—Ä—è–µ–º ${repoKey} (${branch})`, 'debug', {
            context: 'repoCheck',
            repoKey,
            branch,
            lastCommitSha: repoData.lastCommitSha?.slice(0, 7) || 'none'
          });

          const latestCommit = await github.getBranchLastCommit(owner, repo, branch);

          if (!latestCommit || !latestCommit.sha) {
            logError(`–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∫–æ–º–º–∏—Ç –¥–ª—è ${repoKey}`, null, {
              context: 'repoCheck',
              repoKey,
              branch,
              errorType: 'NO_COMMIT_DATA'
            });
            failedChecks++;
            continue;
          }

          if (!repoData.lastCommitSha) {
            await storage.updateRepoCommit(owner, repo, latestCommit);
            log(`–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω –Ω–æ–≤—ã–π —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π: ${repoKey}`, 'info', {
              context: 'repoInit',
              repoKey,
              branch,
              newCommitSha: latestCommit.sha.slice(0, 7)
            });
            successfulChecks++;
            continue;
          }

          if (latestCommit.sha !== repoData.lastCommitSha) {
            log(`–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤ ${repoKey}`, 'info', {
              context: 'repoUpdate',
              repoKey,
              branch,
              oldCommitSha: repoData.lastCommitSha.slice(0, 7),
              newCommitSha: latestCommit.sha.slice(0, 7),
              commitMessage: latestCommit.commit.message.split('\n')[0]
            });

            updates.push({
              repoKey,
              branch,
              newSha: latestCommit.sha,
              oldSha: repoData.lastCommitSha,
              message: latestCommit.commit.message.split('\n')[0],
              url: latestCommit.html_url
            });

            await storage.updateRepoCommit(owner, repo, latestCommit);
            await this.sendUpdateNotification(bot, updates[updates.length - 1]);
          }

          successfulChecks++;

        } catch (error) {
          failedChecks++;
          logError(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ ${repoKey}`, error, {
            context: 'repoCheck',
            repoKey,
            branch: repoData.branch,
            lastCommitSha: repoData.lastCommitSha?.slice(0, 7),
            errorType: error.response?.status ? 'API_ERROR' : 'NETWORK_ERROR',
            statusCode: error.response?.status,
            responseData: error.response?.data ? JSON.stringify(error.response.data).substring(0, 200) : null
          });
        }
      }

      const duration = Date.now() - startTime;
      log('–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–µ–≤ –∑–∞–≤–µ—Ä—à–µ–Ω–∞', 'info', {
        context: 'checkAllReposSummary',
        durationMs: duration,
        totalRepos: repos.length,
        processedRepos,
        successfulChecks,
        failedChecks,
        updatesFound: updates.length,
        performance: {
          msPerRepo: duration / repos.length,
          reposPerSecond: (repos.length / (duration / 1000)).toFixed(2)
        }
      });

      return updates;
    } catch (error) {
      const duration = Date.now() - startTime;
      logError('–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ checkAllRepos', error, {
        context: 'checkAllRepos',
        stack: error.stack,
        timestamp: new Date().toISOString(),
        durationMs: duration,
        processedRepos,
        successfulChecks,
        failedChecks
      });
      return [];
    }
  },

  async sendUpdateNotification(bot, update) {
    try {
      const message = this.formatUpdateMessage(update);
      const keyboard = this.createNotificationKeyboard(update);
      
      const sentMessage = await bot.telegram.sendMessage(
        process.env.ADMIN_USER_ID,
        message,
        { 
          disable_web_page_preview: true,
          reply_markup: keyboard,
          parse_mode: 'HTML'
        }
      );

      log('–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ', 'info', {
        context: 'sendUpdateNotification',
        repoKey: update.repoKey,
        branch: update.branch,
        newSha: update.newSha.slice(0, 7),
        buttonsCount: keyboard.inline_keyboard.flat().length,
        messageId: sentMessage.message_id
      });

    } catch (error) {
      logError('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è', error, {
        context: 'sendUpdateNotification',
        repoKey: update.repoKey,
        chatId: process.env.ADMIN_USER_ID,
        errorMessage: error.message,
        stack: error.stack
      });
    }
  },

  createNotificationKeyboard(update) {
    try {
      const [owner, repo] = update.repoKey.split('/');
      const buttons = [];
      
      // –ö–Ω–æ–ø–∫–∞ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ PR (–µ—Å–ª–∏ –µ—Å—Ç—å –Ω–æ–º–µ—Ä PR)
      const prMatch = update.message.match(/#(\d+)/);
      if (prMatch && prMatch[1]) {
        buttons.push([{
          text: "üìå –ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å PR",
          callback_data: `prview_${owner}_${repo}_${prMatch[1]}`
        }]);
      }

      // –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã
      buttons.push(
  [{
    text: "üåø 3 –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –∫–æ–º–º–∏—Ç–∞",
    callback_data: `quick_last_${owner}_${repo}_3`
  }],
  [{
    text: "üìä 10 –∞–∫—Ç–∏–≤–Ω—ã—Ö –≤–µ—Ç–æ–∫",
    callback_data: `quick_branches_${owner}_${repo}_10`
  }],
  [{
    text: "üîÑ 10 –ø–æ—Å–ª–µ–¥–Ω–∏—Ö PR",
    callback_data: `quick_pr_${owner}_${repo}_10_open`
  }]
);

      // –ö–Ω–æ–ø–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ–º
      buttons.push([{
        text: "‚ùå –£–¥–∞–ª–∏—Ç—å —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π",
        callback_data: `confirm_remove_${update.repoKey}`
      }]);

      log('–°–æ–∑–¥–∞–Ω–∞ –∫–æ–º–ø–ª–µ–∫—Å–Ω–∞—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è', 'debug', {
        context: 'createNotificationKeyboard',
        repoKey: update.repoKey,
        hasPRButton: !!prMatch,
        totalButtons: buttons.flat().length
      });

      return { inline_keyboard: buttons };
      
    } catch (error) {
      logError('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã', error, {
        context: 'createNotificationKeyboard',
        repoKey: update.repoKey
      });
      return { inline_keyboard: [] };
    }
  },

  formatUpdateMessage(update) {
    const prMatch = update.message.match(/#(\d+)/);
    let prInfo = '';
    
    if (prMatch && prMatch[1]) {
      prInfo = `\nüìå –°–≤—è–∑–∞–Ω–Ω—ã–π PR: #${prMatch[1]}`;
    }
    
    return `
üîÑ <b>–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤ ${update.repoKey} (${update.branch})</b>
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
<b>–ë—ã–ª–æ:</b> <code>${update.oldSha.slice(0, 7)}</code>
<b>–°—Ç–∞–ª–æ:</b> <code>${update.newSha.slice(0, 7)}</code>${prInfo}
üìù ${update.message.substring(0, 100)}
üîó ${update.url}

<i>–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ –¥–ª—è –±—ã—Å—Ç—Ä—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π:</i>
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
    `;
  }
};